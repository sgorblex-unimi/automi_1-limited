\chapter{\eng{Witness languages}}
Ai fini di ottenere o migliorare i lower bound, di risolvere i problemi aperti e in generale di ottenere una conoscenza più approfondita di un modello oggetto di studio, vengono studiati dei \eng{witness languages} ("linguaggi testimoni"), linguaggi la cui esistenza dimostra una congettura. Nella sezione \ref{subs:a1l:low} abbiamo studiato la famiglia di linguaggi $L_n$, testimone del lower bound di conversione da \la1 e 1DFA doppiamente esponenziale e da \la1 a 1NFA, 2NFA, 2DFA, D\la1 semplicemente esponenziale. In questo capitolo espandiamo lo studio di questi linguaggi introducendone di nuovi, costruendone altri riconoscitori e dimostrando l'ottimalità dei bound che li riguardano. Classifichiamo tali linguaggi in base a una caratteristica comune che ne rende lo studio (almeno in parte) uniforme: a blocchi, unari, con reset, algebrici. I linguaggi unari, in particolare, sono di interesse in quanto il caso unario è considerato speciale nello studio dei linguaggi formali (poiché non c'è distinzione tra unari regolari e unari context-free), ed è oggetto di problemi aperti.



\section{Linguaggi a blocchi}\label{sec:wit:blk}
In un linguaggio a blocchi di parametro $n$, ogni parola è composta dalla concatenazione di stringhe di lunghezza $n$, dette blocchi. Condizioni diverse sulla relazione tra i blocchi danno origine a diverse famiglie di linguaggi, ad esempio:
\begin{itemize}
	\item il linguaggio delle parole in cui l'ultimo blocco è uguale a uno dei precedenti:
	      \begin{equation*}
		      K_n := \{ x_1\cdots x_kx \mid k>0, x_1,\dots,x_k\in\{a,b\}^n, \exists j\in\{1,\dots,k\},x_j=x\}
	      \end{equation*}
	\item il linguaggio delle parole in cui due blocchi qualsiasi sono uguali:
	      \begin{equation*}
		      E_n := \{x_1\cdots x_k \mid k>0, x_1,\dots,x_k\in\{a,b\}^n,\exists i,j\in\{1,\dots,k\},i<j,x_i=x_j\}
	      \end{equation*}
	\item il linguaggio in cui $n$ blocchi sono uguali:
	      \begin{align*}
		      L_n := \{ & x_1x_2\cdots x_k\mid k\geq0, x_1,x_2,\dots,x_k\in\{0,1\}^n,                                  \\
		                & \exists i_1,i_2,\dots,i_n\in\{1,\dots,k\},i_1<i_2<\dots<i_n, x_{i_1}=x_{i_2}=\dots=x_{i_n}\}
	      \end{align*}
\end{itemize}

Per $L_n$ sono stati descritti al paragrafo \ref{subs:a1l:low} un \la1 riconoscitore e il lower bound sul numero di stati di un 1DFA, un \la1, e 1NFA, 2NFA, 2DFA o D\la1 che riconoscano $L_n$. Gli stessi risultati possono essere facilmente adattati agli altri due linguaggi presentati, usando una variante dell'algoritmo \ref{alg:a1l:lowLn:3f} per il riconoscimento e la distinguibilità per i lower bound. Questo dimostra che i tre linguaggi sono testimoni della distanza doppiamente esponenziale di complessità tra \la1 e 1DFA, di quella semplicemente esponenziale tra \la1 e NFA, 2NFA, 2DFA, e di quella almeno esponenziale tra \la1 e D\la1.


\subsection{Riconoscitori}
Descriviamo ora gli upper bound mancanti per il riconoscimento di questi linguaggi, cioè D\la1, 2NFA, 2DFA e 1NFA. Usiamo ancora una volta l'esempio di $L_n$ poiché le tecniche sono molto simili tra i diversi linguaggi.

\subsubsection{1DFA}
% TODO: immagine?
Un 1DFA che riconosca $L_n$ può, scansionando l'input da sinistra verso destra, contare le occorrenze di ogni possibile blocco. Per fare ciò, ogni blocco $x\in\set{0,1}^n$ ha un contatore associato. Per l'identificazione di un blocco, gli stati sono organizzati ad albero, in cui ogni ramo è prefisso di un blocco e una foglia coincide con l'incremento del contatore, nonché la radice dell'albero successivo. Trovata la $n$-esima occorrenza di un blocco, l'automa si limita a contare modulo $n$ la restante lunghezza della parola di input per verificare la struttura a blocchi. Per la prima fase sono richiesti $n^{2^n}$ stati per i contatori, ciascuno dipendente da un albero di $2^n-1$ stati, mentre per la seconda fase sono sufficienti $n$ stati, per un totale di $(2^n-1)\cdot n^{2^n}+n$ stati.

\subsubsection{1NFA}
% TODO: immagine?
Un 1NFA che riconosca $L_n$ può provare a indovinare una stringa che ritiene essere il blocco ripetuto, quindi scansionando l'input verificare che tale blocco compaia $n$ volte. L'automa usa un contatore da $0$ a $n$ per le occorrenze del blocco candidato e uno modulo $n$ che verifichi la lunghezza dell'input per la struttura a blocchi. Una volta trovate $n$ occorrenze del blocco, l'automa si limita a verificare la lunghezza dell'input rimanente. Includendo uno stato iniziale, si ha un totale di $(2n-1)\cdot n\cdot 2^n+n+1$ stati.

% TODO: numero di stati?
\subsubsection{2DFA}
Un 2DFA può riconoscere $L_n$ eseguendo innanzitutto una scansione preliminare che verifichi che la lunghezza dell'input è multipla di $n$, quindi effettuando una scansione del nastro per ogni possibile blocco, contando le occorrenze di quello corrente (con una strategia simile a quella dell'1NFA descritto precedentemente), finché trovando $n$ occorrenze di un blocco può semplicemente accettare violando l'end-marker destro.

Questa macchina è anche un 2NFA e D\la1, che non hanno riconoscitori migliori che sfruttino le capacità in più dei rispettivi modelli.



\section{Linguaggi unari}\label{sec:wit:un}
La relazione tra automi limited e linguaggi unari è stata studiata estensivamente da Pighizzini e Prigioniero in \cite{Pighizzini:19:limitedunary}. In particolare, i \la1 che riconoscono linguaggi unari possono fare uso di una tecnica basata sulla \eng{binary carry sequence}:
\begin{defin}
	La \emph{binary carry sequence} è la successione infinita di interi $\sigma_1\sigma_2\cdots\sigma_j\cdots$ in cui $\sigma_j$ è l'esponente della più alta potenza di $2$ che divide $j$, per ogni intero $j\geq1$.
\end{defin}

Definiamo inoltre la \eng{backward increasing sequence}, una funzione che trasforma sequenze che ha proprietà interessanti in relazione alla binary carry sequence.
\begin{defin}
	Sia $s=k_1k_2\cdots k_j$ una sequenza finita di interi. La \emph{backward increasing sequence} di $s$, denotata con $\bis(s)$, è la più lunga successione ottenibile selezionando da destra verso sinistra gli elementi di $s$ solo finché si susseguono in ordine crescente. Formalmente, $\bis(k_1k_2\cdots k_j)=(i_1,i_2,\dots,i_r)$ se e solo se $i_1=k_{h_1},i_2=k_{h_2}\dots i_r=k_{h_r}$ dove $h_1=j$ e $h_t=\max\set{h'<h_{t-1}\mid k_{h'}>k_{h_{t-1}}}$.
\end{defin}

Si verifica il seguente risultato, dimostrato in \cite{Pighizzini:19:limitedunary}:
\begin{lemma}\label{lem:wit:bis}
	Sia $\sigma_1\sigma_2\cdots\sigma_j$ il prefisso di lunghezza $j$ della binary carry sequence.
	\begin{itemize}
		\item \label{lem:wit:bis:1} Se $\bis(\sigma_1\sigma_2\cdots\sigma_j)=(i_1,i_2,\dots,i_r)$ allora
		      \begin{equation*}
			      j=\sum_{t=1}^r 2^{i_t}
		      \end{equation*}
		      Ossia, i valori della backward increasing sequence applicata al prefisso di lunghezza $j$ della binary carry sequence corrispondono alle posizioni dei bit a $1$ della rappresentazione binaria di $j$.
		\item \label{lem:wit:bis:2} $o_j$ è il minor numero naturale che non occorre in $\bis(\sigma_1\sigma_2\cdots\sigma_{j-1})$.
	\end{itemize}
\end{lemma}

Spieghiamo ora una tecnica che ci permette di riconoscere diversi linguaggi unari facendo uso del lemma per contare i simboli dell'input. Si prenda in considerazione il linguaggio singoletto $\set{a^{2^n}}$, dove $n>0$ è un parametro intero. Lo scopo della macchina è quello di scrivere il prefisso di lunghezza $2^n$ della binary carry sequence sul nastro, sostituendo le $a$.

% TODO: immagine?
Un \la1 di alfabeto di lavoro $\set{a,0,1,\dots,n}$ può innanzitutto sovrascrivere il primo simbolo con $0$, primo elemento della binary carry sequence. Supponendo che a un certo punto della computazione la macchina abbia scritto il prefisso di lunghezza $j$ della binary carry sequence sovrascrivendo i primi $j$ simboli, il simbolo $\sigma_{j+1}$ può essere calcolato grazie al \hyperref[lem:wit:bis:2]{secondo punto} del lemma \ref{lem:wit:bis}: la macchina può effettuare visite in sola lettura verso sinistra, individuando il più piccolo naturale che non occorre nella backward increasing sequence del prefisso scritto. Tale numero è scritto nella successiva cella scrivibile e il procedimento viene ripetuto. Se a un certo punto della computazione l'automa scrive $n$ ($2^n$-esimo elemento della binary carry sequence) e la successiva cella contiene $\rem$ l'automa accetta. Se si raggiunge $\rem$ senza che $n$ venga scritto allora la parola è troppo corta, mentre se viene scritto ma la successiva cella non contiene l'end-marker la parola è troppo lunga. Questa macchina può essere implementata in $O(n)$ stati e fare uso di $O(n)$ simboli. Scrivendo al posto di $n$ un simbolo di reset $\reset$, in cui l'automa si comporta come sull'end-marker sinistro, si adatta la macchina ad accettare $\set{a^{2^n}}\star$ quando $\lem$ o $\reset$ precedono $\rem$. Un 2NFA necessita di $2^n$ stati per riconoscere questo linguaggio, come dimostrato in \cite{Mereghetti:00:twoway}, ergo esso è testimone della distanza almeno esponenziale da D\la1 a 2NFA (e quindi anche da \la1 e verso 1NFA, 1DFA e 2DFA) per i linguaggi unari.

Una variante di questa tecnica può essere applicata per riconoscere il linguaggio $M_N:=\set{a^N}\star$, con $N>0$ un intero qualsiasi. Per fare ciò, un D\la1 $_N$ può scrivere il prefisso di lunghezza $N-1$ della binary carry sequence con la tecnica descritta precedentemente, quindi scrivere un simbolo di reset $\reset$ che equivale a $\lem$ e impone alla macchina di ricominciare la scrittura dal simbolo $\sigma_1$. Questo procedimento viene ripetuto per tutto l'input: la stringa ha lunghezza multipla di $N$ se e solo se l'ultimo simbolo prima dell'end-marker destro è $\reset$ o $\lem$. Se $w$ è l'input il nastro verrà riscritto come segue:
\begin{equation*}
	\underbrace{\sigma_1\cdots\sigma_{N-1}\reset\cdots\reset\sigma_1\cdots\sigma_{N-1}\reset}_{\floor{\len w/N} \text{ volte}}\sigma_1\cdots\sigma_{\scriptscriptstyle \len w\mkern -11mu \mod N}
\end{equation*}
Poiché $N$ non è necessariamente una potenza di $2$, rilevare quando è il momento di scrivere $\reset$ non è triviale. Per fare ciò $B_N$, durante procedimento di identificazione del prossimo simbolo da scrivere, verifica inoltre se la backward increasing sequence del prefisso attuale rappresenta il numero $N-1$. Se così fosse, il \hyperref[lem:wit:bis:1]{primo punto} del lemma \ref{lem:wit:bis} dimostra che il prefisso attuale ha lunghezza $N-1$, e che quindi il prossimo simbolo da scrivere è $\reset$.

L'implementazione di $B_N$ richiede un numero di stati e un alfabeto di lavoro lineari nel massimo elemento della binary carry sequence che può essere scritto, ossia $O(\log N)$.

% TODO: guardare articolo unari e decidere se inserire qualcosa



\section{Linguaggi con reset}
Con l'intenzione di studiare un witness language che non fosse né unario né a blocchi, Pighizzini, Prigioniero e Sádovský hanno studiato in \cite{Pighizzini:22:limitedwitness} il riconoscimento da parte di \la1 del linguaggio accettato dall'automa $S_N$, introdotto da Meyer e Fischer in \cite{Meyer:71:ecodescription} come testimone della distanza esponenziale tra 1NFA e 1DFA. L'automa, rappresentato in figura \ref{img:wit:Sn}, ha una struttura ciclica: se si considerano solo le transizioni generate dal simbolo $a$ l'automa riconosce il linguaggio $\set{a^N}\star$. Il ruolo di $b$ è scelto nondeterministicamente tra due: o viene ignorato, lasciando invariato lo stato, o impone alla macchina un reset, riportandola allo stato iniziale.

\begin{figure}
	\centering
	\input{img/Sn.tikz}
	\caption{L'NFA $S_N$ di Meyer e Fischer.}
	\label{img:wit:Sn}
\end{figure}

Viene dimostrato in \cite{Meyer:71:ecodescription} che il minimo 1DFA equivalente a $S_N$ ha $2^N$ stati. In \cite{Pighizzini:22:limitedwitness} viene costruito un 2DFA di $N+2$ stati equivalente a $S_N$, il che testimonia la distanza esponenziale tra D\la1 e 1DFA, e viene dimostrato che il minimo 2NFA equivalente a $S_{2^n}$, con $n>0$, ha almeno $2^n$ stati.

Per simulare con \la1 automi con un meccanismo di reset simile a quello di $S_N$, si può sfruttare una variante della tecnica basata sulla binary carry sequence di cui al paragrafo \ref{sec:wit:un}. In particolare, per ogni $N>1$, $S_N$ può essere riconosciuto da un \la1 $C_N$ con $O(\log N)$ stati e un alfabeto di lavoro di $O(\log N)$ simboli.
Poiché, come accennato in precedenza, restringendo il comportamento di $S_N$ al solo input $a$ si riconosce il linguaggio unario $\set{a^N}\star$, in questo caso $C_N$ può comportarsi esattamente come $B_N$, l'automa che riconosce tale linguaggio. $C_N$ costruisce quindi una serie di ripetizioni del prefisso di lunghezza $N-1$ della binary carry sequence, separandole con il carattere di reset $\reset$. Per quanto riguarda il comportamento di $C_N$ per il simbolo di input $b$, la macchina può scegliere nondeterministicamente di effettuare una di due mosse, ciascuna corrispondente con uno dei comportamenti di $S_N$ leggendo $b$:
\begin{itemize}
	\item per simulare le transizioni che non cambiano stato, $C_N$ sovrascrive $b$ con un simbolo $\neutr$ neutrale, nel senso che il comportamento della macchina in esso sarà semplicemente di procedere senza tenerlo in considerazione;
	\item per simulare le transizioni di reset, $C_N$ sovrascrive $b$ con il simbolo di reset $\reset$. Si noti che sia in questo caso sia se il ciclo di $\set{a^N}\star$ viene completato il simbolo $\reset$ corrisponde agli istanti in cui $S_N$ passa allo stato $q_0$.
\end{itemize}
Se si incontra $b$ a destra di $\lem$ o di $\reset$, la mossa non è definita, così come non lo è in $q_0$ per $S_N$. $C_N$ accetta se e solo se $\reset$ o $\lem$ sono seguiti da $\rem$. L'incremento di stati e di simboli rispetto a $B_N$ è trascurabile ed entrambi rimangono in numero di $O(\log N)$.

In conclusione il linguaggio $\generated{S_N}$ è testimone del gap esponenziale tra \la1 e 1NFA e doppiamente esponenziale tra \la1 e 1DFA.



\section{Problemi aperti e ricerche future}
Lo studio dei $1$-limited e del loro rapporto con altri riconoscitori, pur avendo portato a risultati soddisfacenti nei casi principali (1NFA, 1DFA), lascia diverse domande senza risposta.


\subsection{L'eliminazione del nondeterminismo}
Il più importante dei problemi aperti che riguardano i $1$-limited è il gap di complessità descrizionale tra \la1 e D\la1, di cui conosciamo un lower bound esponenziale (corollario \ref{cor:a1l:LAtoDLA}) e un upper bound doppiamente esponenziale, derivante dalla simulazione degli \la1 da parte dei 1DFA. Non abbiamo, tra l'altro, evidenze di una distanza maggiore tra \la1 e 2DFA.

Pighizzini, Prigioniero e Sádovský (\cite{Pighizzini:22:limitedwitness}) hanno proposto, con l'intenzione di introdurre dei witness language per una ipotetica distanza più che esponenziale tra \la1 e D\la1 (o tra \la1 e 2DFA), due linguaggi binari basati sulla parità (XOR). Il linguaggio $P_n$ è un linguaggio a blocchi, in cui lo XOR di un certo numero di blocchi risulta nell'ultimo blocco. Il linguaggio $P'_n$ è una versione di $P_n$ in cui cade il vincolo dei blocchi, permettendo lo XOR di qualunque sottostringa che non si sovrapponga:
\begin{align*}
	P_n := \{  x_1\dots x_kx \mid ~ & k>0, x_1,\dots,x_k,x\in\{0,1\}^n,                                \\
	                                & \exists h>0,i_1,i_2,\dots,x_h\in\{1,\dots,k\},i_1<i_2<\dots<i_h: \\
	                                & x=x_{i_1}\oplus x_{i_2}\oplus\dots\oplus x_{i_h}\}
\end{align*}
\begin{align*}
	P'_n := \{  wx \mid ~ & w\in\{0,1\}^*,x\in\{0,1\}^n,                                              \\
	                      & \exists h>0,x_1,x_2,\dots,x_h\in\{0,1\}^n,y_0,y_1,\dots,y_h\in\{0,1\}^*:  \\
	                      & w=y_0x_1y_1\dots y_{n-1}x_hy_h \land x=x_1\oplus x_2\oplus\dots\oplus x_h\}
\end{align*}

Questi linguaggi possono essere riconosciuti da un \la1 lineare in $n$ con un adattamento delle tecniche per i linguaggi a blocchi (paragrafo \ref{sec:wit:blk}), tuttavia è sconosciuto un lower bound per un 1DFA equivalente. Rimane una congettura, per il momento, che questi linguaggi non siano accettati da D\la1 o 2DFA di dimensione semplicemente esponenziale.


\subsection{Simulazioni mancanti}
Non si conoscono simulazioni che permettano, a partire da un \la1, di rimuovere il nondeterminismo (\la1\tto D\la1), la capacità di riscrittura (\la1\tto 2NFA), o la combinazione delle due (\la1\tto 2DFA), se non quella in 1NFA e 1DFA.

In effetti, non si conosce una costruzione che permetta di convertire un 2NFA in un 2DFA (o un 1NFA in un 2DFA), di cui si conosce un lower bound polinomiale e un upper bound esponenziale. Pur non risolvendo questo problema, sarebbe interessante investigare la sua potenziale correlazione con la simulazione di \la1 da parte di D\la1. In particolare, l'eliminazione del nondeterminismo da una macchina two-way potrebbe sfruttare una tecnica adattabile al caso \la1\tto D\la1.

Per quanto riguarda l'eliminazione della capacità di riscrittura, ci sembra improbabile trovare una tecnica che permetta di codificare nel solo movimento two-way, anche se nondeterministico, i possibili stati del nastro modificato.


\subsection{Il caso unario}
Per quanto riguarda i linguaggi unari, lo sviluppo della tecnica basata sulla binary carry sequence (paragrafo \ref{sec:wit:un}) ha portato alla determinazione di diversi testimoni della distanza almeno esponenziale tra \la1 e 1DFA. Non si conosce una simulazione che limiti la distanza nel caso unario a semplicemente esponenziale, né sono stati trovati lower bound maggiori, pertanto il gap tra \la1 e 1DFA per gli unari rimane un problema aperto, la cui risposta è inclusa tra il singolo e il doppio esponenziale.

% TODO: aggiungere tabella/mappa dei bound
