\chapter{\eng{Witness languages}}
Ai fini di ottenere o migliorare i lower bound, di risolvere i problemi aperti e in generale di ottenere una conoscenza più approfondita di un modello oggetto di studio, vengono studiati dei \eng{witness languages} ("linguaggi testimoni"), linguaggi la cui esistenza dimostra una congettura. Nella sezione \ref{subs:a1l:low} abbiamo studiato la famiglia di linguaggi $L_n$, testimone del lower bound di conversione da \la1 e 1DFA doppiamente esponenziale e da \la1 a 1NFA, 2NFA, 2DFA, D\la1 semplicemente esponenziale. In questo capitolo espandiamo lo studio di questi linguaggi introducendone di nuovi, costruendone altri riconoscitori e dimostrando l'ottimalità dei bound che li riguardano. Classifichiamo tali linguaggi in base a una caratteristica comune che ne rende lo studio (almeno in parte) uniforme: a blocchi, unari, con reset, algebrici. I linguaggi unari, in particolare, sono di interesse in quanto il caso unario è considerato speciale nello studio dei linguaggi formali (poiché non c'è distinzione tra unari regolari e unari context-free), ed è oggetto di problemi aperti.



\section{Linguaggi a blocchi}
In un linguaggio a blocchi di parametro $n$, ogni parola è composta dalla concatenazione di stringhe di lunghezza $n$, dette blocchi. Condizioni diverse sulla relazione tra i blocchi danno origine a diverse famiglie di linguaggi, ad esempio:
\begin{itemize}
	\item il linguaggio delle parole in cui l'ultimo blocco è uguale a uno dei precedenti:
	      \begin{equation*}
		      K_n := \{ x_1\cdots x_kx \mid k>0, x_1,\dots,x_k\in\{a,b\}^n, \exists j\in\{1,\dots,k\},x_j=x\}
	      \end{equation*}
	\item il linguaggio delle parole in cui due blocchi qualsiasi sono uguali:
	      \begin{equation*}
		      E_n := \{x_1\cdots x_k \mid k>0, x_1,\dots,x_k\in\{a,b\}^n,\exists i,j\in\{1,\dots,k\},i<j,x_i=x_j\}
	      \end{equation*}
	\item il linguaggio in cui $n$ blocchi sono uguali:
	      \begin{align*}
		      L_n := \{ & x_1x_2\cdots x_k\mid k\geq0, x_1,x_2,\dots,x_k\in\{0,1\}^n,                                  \\
		                & \exists i_1,i_2,\dots,i_n\in\{1,\dots,k\},i_1<i_2<\dots<i_n, x_{i_1}=x_{i_2}=\dots=x_{i_n}\}
	      \end{align*}
\end{itemize}

Per $L_n$ sono stati descritti al paragrafo \ref{subs:a1l:low} un \la1 riconoscitore e il lower bound sul numero di stati di un 1DFA, un \la1, e 1NFA, 2NFA, 2DFA o D\la1 che riconoscano $L_n$. Gli stessi risultati possono essere facilmente adattati agli altri due linguaggi presentati, usando una variante dell'algoritmo \ref{alg:a1l:lowLn:3f} per il riconoscimento e la distinguibilità per i lower bound. Questo dimostra che i tre linguaggi sono testimoni della distanza doppiamente esponenziale di complessità tra \la1 e 1DFA, di quella semplicemente esponenziale tra \la1 e NFA, 2NFA, 2DFA, e di quella almeno esponenziale tra \la1 e D\la1.


\subsection{Riconoscitori}
Descriviamo ora gli upper bound mancanti per il riconoscimento di questi linguaggi, cioè D\la1, 2NFA, 2DFA e 1NFA. Usiamo ancora una volta l'esempio di $L_n$ poiché le tecniche sono molto simili tra i diversi linguaggi.

\subsubsection{1DFA}
% TODO: immagine?
Un 1DFA che riconosca $L_n$ può, scansionando l'input da sinistra verso destra, contare le occorrenze di ogni possibile blocco. Per fare ciò, ogni blocco $x\in\set{0,1}^n$ ha un contatore associato. Per l'identificazione di un blocco, gli stati sono organizzati ad albero, in cui ogni ramo è prefisso di un blocco e una foglia coincide con l'incremento del contatore, nonché la radice dell'albero successivo. Trovata la $n$-esima occorrenza di un blocco, l'automa si limita a contare modulo $n$ la restante lunghezza della parola di input per verificare la struttura a blocchi. Per la prima fase sono richiesti $n^{2^n}$ stati per i contatori, ciascuno dipendente da un albero di $2^n-1$ stati, mentre per la seconda fase sono sufficienti $n$ stati, per un totale di $(2^n-1)\cdot n^{2^n}+n$ stati.

\subsubsection{1NFA}
% TODO: immagine?
Un 1NFA che riconosca $L_n$ può provare a indovinare una stringa che ritiene essere il blocco ripetuto, quindi scansionando l'input verificare che tale blocco compaia $n$ volte. L'automa usa un contatore da $0$ a $n$ per le occorrenze del blocco candidato e uno modulo $n$ che verifichi la lunghezza dell'input per la struttura a blocchi. Una volta trovate $n$ occorrenze del blocco, l'automa si limita a verificare la lunghezza dell'input rimanente. Includendo uno stato iniziale, si ha un totale di $(2n-1)\cdot n\cdot 2^n+n+1$ stati.

% TODO: numero di stati?
\subsubsection{2DFA}
Un 2DFA può riconoscere $L_n$ eseguendo innanzitutto una scansione preliminare che verifichi che la lunghezza dell'input è multipla di $n$, quindi effettuando una scansione del nastro per ogni possibile blocco, contando le occorrenze di quello corrente (con una strategia simile a quella dell'1NFA descritto precedentemente), finché trovando $n$ occorrenze di un blocco può semplicemente accettare violando l'end-marker destro.

Questa macchina è anche un 2NFA e D\la1, che non hanno riconoscitori migliori che sfruttino le capacità in più dei rispettivi modelli.



\section{Linguaggi unari}
La relazione tra automi limited e linguaggi unari è stata studiata estensivamente da Pighizzini e Prigioniero in \cite{Pighizzini:19:limitedunary}. In particolare, i \la1 che riconoscono linguaggi unari possono fare uso di una tecnica basata sulla \eng{binary carry sequence}:
\begin{defin}
	La \emph{binary carry sequence} è la successione infinita di interi $\sigma_1\sigma_2\cdots\sigma_j\cdots$ in cui $\sigma_j$ è l'esponente della più alta potenza di $2$ che divide $j$, per ogni intero $j\geq1$.
\end{defin}

Definiamo inoltre la \eng{backward increasing sequence}, una funzione che trasforma sequenze che ha proprietà interessanti in relazione alla binary carry sequence.
\begin{defin}
	Sia $s=k_1k_2\cdots k_j$ una sequenza finita di interi. La \emph{backward increasing sequence} di $s$, denotata con $\bis(s)$, è la più lunga successione ottenibile selezionando da destra verso sinistra gli elementi di $s$ solo finché si susseguono in ordine crescente. Formalmente, $\bis(k_1k_2\cdots k_j)=(i_1,i_2,\dots,i_r)$ se e solo se $i_1=k_{h_1},i_2=k_{h_2}\dots i_r=k_{h_r}$ dove $h_1=j$ e $h_t=\max\set{h'<h_{t-1}\mid k_{h'}>k_{h_{t-1}}}$.
\end{defin}

Si verifica il seguente risultato, dimostrato in \cite{Pighizzini:19:limitedunary}:
\begin{lemma}\label{lem:wit:bis}
	Sia $\sigma_1\sigma_2\cdots\sigma_j$ il prefisso di lunghezza $j$ della binary carry sequence.
	\begin{itemize}
		\item \label{lem:wit:bis:1} Se $\bis(\sigma_1\sigma_2\cdots\sigma_j)=(i_1,i_2,\dots,i_r)$ allora
		      \begin{equation*}
			      j=\sum_{t=1}^r 2^{i_t}
		      \end{equation*}
		      Ossia, i valori della backward increasing sequence applicata al prefisso di lunghezza $j$ della binary carry sequence corrispondono alle posizioni dei bit a $1$ della rappresentazione binaria di $j$.
		\item \label{lem:wit:bis:2} $o_j$ è il minor numero naturale che non occorre in $\bis(\sigma_1\sigma_2\cdots\sigma_{j-1})$.
	\end{itemize}
\end{lemma}

Spieghiamo ora una tecnica che ci permette di riconoscere diversi linguaggi unari facendo uso del lemma per contare i simboli dell'input. Si prenda in considerazione il linguaggio singoletto $\set{a^{2^n}}$, dove $n>0$ è un parametro intero. Lo scopo della macchina è quello di scrivere il prefisso di lunghezza $2^n$ della binary carry sequence sul nastro, sostituendo le $a$.

% TODO: immagine?
Un \la1 di alfabeto di lavoro $\set{a,0,1,\dots,n}$ può innanzitutto sovrascrivere il primo simbolo con $0$, primo elemento della binary carry sequence. Supponendo che a un certo punto della computazione la macchina abbia scritto il prefisso di lunghezza $j$ della binary carry sequence sovrascrivendo i primi $j$ simboli, il simbolo $\sigma_{j+1}$ può essere calcolato grazie al \hyperref[lem:wit:bis:2]{secondo punto} del lemma \ref{lem:wit:bis}: la macchina può effettuare visite in sola lettura verso sinistra, individuando il più piccolo naturale che non occorre nella backward increasing sequence del prefisso scritto. Tale numero è scritto nella successiva cella scrivibile e il procedimento viene ripetuto. Se a un certo punto della computazione l'automa scrive $n$ ($2^n$-esimo elemento della binary carry sequence) e la successiva cella contiene $\rem$ l'automa accetta. Se si raggiunge $\rem$ senza che $n$ venga scritto allora la parola è troppo corta, mentre se viene scritto ma la successiva cella non contiene l'end-marker la parola è troppo lunga. Questa macchina può essere implementata in $O(n)$ stati e fare uso di $O(n)$ simboli. Scrivendo al posto di $n$ un simbolo di reset $\reset$, in cui l'automa si comporta come sull'end-marker sinistro, si adatta la macchina ad accettare $\set{a^{2^n}}\star$ quando $\lem$ o $\reset$ precedono $\rem$. Un 2NFA necessita di $2^n$ stati per riconoscere questo linguaggio, come dimostrato in \cite{Mereghetti:00:twoway}, ergo esso è testimone della distanza almeno esponenziale da D\la1 a 2NFA (e quindi anche da \la1 e verso 1NFA, 1DFA e 2DFA) per i linguaggi unari.

Una variante di questa tecnica può essere applicata per riconoscere il linguaggio $M_N:=\set{a^N}\star$, con $N>0$ un intero qualsiasi. Per fare ciò, un D\la1 $_N$ può scrivere il prefisso di lunghezza $N-1$ della binary carry sequence con la tecnica descritta precedentemente, quindi scrivere un simbolo di reset $\reset$ che equivale a $\lem$ e impone alla macchina di ricominciare la scrittura dal simbolo $\sigma_1$. Questo procedimento viene ripetuto per tutto l'input: la stringa ha lunghezza multipla di $N$ se e solo se l'ultimo simbolo prima dell'end-marker destro è $\reset$ o $\lem$. Se $w$ è l'input il nastro verrà riscritto come segue:
\begin{equation*}
	\underbrace{\sigma_1\cdots\sigma_{N-1}\reset\cdots\reset\sigma_1\cdots\sigma_{N-1}\reset}_{\floor{\len w/N} \text{ volte}}\sigma_1\cdots\sigma_{\scriptscriptstyle \len w\mkern -11mu \mod N}
\end{equation*}
Poiché $N$ non è necessariamente una potenza di $2$, rilevare quando è il momento di scrivere $\reset$ non è triviale. Per fare ciò $B_N$, durante procedimento di identificazione del prossimo simbolo da scrivere, verifica inoltre se la backward increasing sequence del prefisso attuale rappresenta il numero $N-1$. Se così fosse, il \hyperref[lem:wit:bis:1]{primo punto} del lemma \ref{lem:wit:bis} dimostra che il prefisso attuale ha lunghezza $N-1$, e che quindi il prossimo simbolo da scrivere è $\reset$.

L'implementazione di $B_N$ richiede un numero di stati e un alfabeto di lavoro lineari nel massimo elemento della binary carry sequence che può essere scritto, ossia $O(\log N)$.

% TODO: guardare articolo unari e decidere se inserire qualcosa



\section{Linguaggi con reset}



\section{Linguaggi algebrici}
