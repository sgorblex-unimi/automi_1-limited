\chapter{Preliminari}
La teoria dei linguaggi formali è un campo fondamentale dell'informatica teorica e studia i linguaggi, cioè insiemi di parole, e i loro generatori o riconoscitori. Questo campo, sebbene strettamente legato alla linguistica, ha implicazioni enormi nell'informatica e nella matematica, per esempio nei campi della computabilità, della programmazione, della crittografia e della logica. In questo capitolo ricordiamo al lettore le nozioni fondamentali della teoria dei linguaggi, delle grammatiche e dei principali riconoscitori, di cui studieremo il rapporto con gli automi \eng{$1$-limited}.



\section{Linguaggi}
In questa sezione introduciamo le definizioni fondamentali della teoria dei linguaggi, inclusi alfabeti, parole e linguaggi stessi. La maggior parte dei concetti è espresso nella formalizzazione di \cite{Hopcroft:01:introLFA2}, che invitiamo il lettore a consultare per approfondimenti. Alcuni concetti sono ripresi da \cite{Bertoni:04:dispLFA}.


\subsection*{Alfabeti}
Tutte le nozioni di base della teoria dei linguaggi partono dalla definizione di alfabeto, simile a quello dei linguaggi naturali (le lingue parlate e scritte): un insieme di lettere.
\begin{defin}[alfabeto]
	Un alfabeto (\eng{alphabet}) è un insieme finito e non vuoto arbitrario, i cui elementi sono detti simboli (\eng{symbol}). Un alfabeto è solitamente indicato con $\Sigma$ o altre lettere greche maiuscole.
\end{defin}
Per chiarezza i simboli di un alfabeto sono spesso indicati con lettere minuscole o cifre numeriche, tuttavia può essere utile usare altri simboli quando la semantica ne viene semplificata.


\subsection*{Parole}
Le parole, costituite da simboli, sono gli elementi che possono formare un linguaggio.

\begin{defin}[parola]
	Una parola $w$ su un alfabeto $\Sigma$ (\eng{word}, o stringa, \eng{string}) è una sequenza finita di simboli appartenenti a $\Sigma$: $w=x_1 x_2 \dots x_n$ con $x_1,x_2,\dots,x_n\in\Sigma$. Le parole si indicano comunemente con lettere latine minuscole.

	La parola non contenente simboli, detta parola vuota, si può costruire da qualunque alfabeto ed è comunemente indicata con $\emptyword$.

	La lunghezza di una parola $w$ è il numero di posizioni per i simboli che la compongono e viene indicata con $|w|$ (o $l(w)$).
\end{defin}
\begin{examp}
	Una parola sull'alfabeto $\Sigma=\set{a,c,s}$ è $w=casa$. La lunghezza di $w$ è $\len w=4$.
\end{examp}
Spesso, con un'improprietà di linguaggio, ci si riferisce alle parole di lunghezza $1$ semplicemente con il simbolo che le compone.

Le potenze di un alfabeto contengono parole di una certa lunghezza su di esso.
\begin{defin}[potenze di un alfabeto]
	Si indica con $\Sigma^n$, con $n\in\N$, l'insieme di parole di lunghezza $n$ su $\Sigma$: $\Sigma^n := \set{w\in\Sigma\star\mid \len{w}=n}$. $\Sigma^0=\set{\emptyword}$ per qualunque $\Sigma$.

	Si indica con $\Sigma\star$ (letto "Sigma star") l'infinito insieme di parole sull'alfabeto $\Sigma$, cioè l'unione di tutte le sue potenze. Si indica con $\Sigma^+$ l'insieme delle parole non vuote su $\Sigma$: $\Sigma^+ := \Sigma\star\setminus\set{\emptyword}$.
\end{defin}

Si possono costruire parole, oltre che da simboli, a partire da altre parole. Il prodotto di giustapposizione di due parole è la parola costruita come l'unione (la giustapposizione) delle due:
\begin{defin}[prodotto di giustapposizione]
	Date due parole $v=x_1\dots x_n$ e $w=y_1\dots y_m$ si dice prodotto di giustapposizione (\eng{concatenation}) di $v$ e $w$ la parola $v\cdot w=x_1\dots x_n y_1\dots y_m$ (anche indicata semplicemente con $vw$) composta dai simboli di $v$ seguiti da quelli di $w$. Si noti che $\len{vw}=\len v+\len w$.
\end{defin}
Il prodotto di giustapposizione $\cdot$ è un'operazione binaria che gode della proprietà associativa e di cui la parola vuota $\emptyword$ è l'elemento neutro, sicché dato un alfabeto $\Sigma$, $(\Sigma,\cdot)$ è un monoide.
\begin{defin}[prefisso, fattore, suffisso]
	Date parole $w$, $x$, $y$, $z$, tali che $w=xyz$ si dice che:
	\begin{itemize}
		\item $x$ è prefisso (\eng{prefix}) di $w$;
		\item $y$ è fattore (\eng{factor}) di $w$;
		\item $z$ è suffisso (\eng{suffix}) di $w$.
	\end{itemize}
\end{defin}
Ovviamente, prefissi, fattori e suffissi di una parola non sono, in generale, unici.


\subsection*{Linguaggi}
I linguaggi, il fondamentale oggetto di studio, sono insiemi di parole su un certo alfabeto.
\begin{defin}[linguaggio]
	Un linguaggio (\eng{language}) $L$ su un alfabeto $\Sigma$ è un insieme di parole su $\Sigma$, ossia un sottoinsieme di $\Sigma\star$:
	\begin{equation*}
		L\subseteq\Sigma\star.
	\end{equation*}
	Il linguaggio $\emptyset$ si dice linguaggio vuoto, da non confondere con il linguaggio $\set{\emptyword}$.
\end{defin}
\begin{examp}
	Un linguaggio su $\Sigma=\set{a,c,s}$ è $L=\set{casa, sacca, cassa, \emptyword}$.
\end{examp}
Si definiscono numerose operazioni dei linguaggi, tra cui una delle più importanti è l'unaria chiusura di Kleene.
\begin{defin}[prodotto di linguaggi]
	Il prodotto di due linguaggi $L_1$ e $L_2$ è il linguaggio delle parole composte ciascuna dalla giustapposizione di una parola di $L_1$ e una di $L_2$:
	\begin{equation*}
		L_1\cdot L_2 := \set{xy\mid x\in L_1 \land y\in L_2}
	\end{equation*}
	Viene indicato con $L^0$ il linguaggio $\set{\emptyword}$, e con $L^n$ il prodotto di un linguaggio $L$ con se stesso $n$ volte:
	\begin{equation*}
		L^n=\begin{cases}
			\set{\emptyword} \qquad & n=0    \\
			L\cdot L^{n-1}\qquad    & n\neq0
		\end{cases}
	\end{equation*}
\end{defin}
\begin{defin}[chiusura di Kleene]
	La chiusura (di Kleene) di un linguaggio $L$ (\eng{Kleene closure}) è il linguaggio $L\star$ delle giustapposizioni di un numero arbitrario di parole di $L$:
	\begin{equation*}
		L\star := L^0\cup L^1\cup\dots=\bigcup_{k=0}^\infty L^k
	\end{equation*}
	Si indica inoltre con $L^+$ il linguaggio $\bigcup_{k=1}^\infty L^k$. Si noti che $L^+=L\star$ se e solo se $\emptyword\in L$.
\end{defin}

Lo studio di linguaggi contenenti parole infinite o su alfabeti infiniti fuoriesce dallo scopo di questo testo. È invece particolarmente interessante studiare linguaggi infiniti, poiché quelli finiti sono triviali da trattare.


\subsection*{Riconoscitori e generatori}
Come si è visto, esistono diversi modi di rappresentare un linguaggio $L$: se è finito è sufficiente elencarne le parole ($L=\set{w_1,w_2,\dots,w_n}$), se è infinito e le sue parole possiedono una proprietà caratterizzante $P$, può essere descritto da essa ($L:=\set{w\mid P(w)}$). Tuttavia, non sempre è facile o rappresentativo usare una di queste rappresentazioni. I metodi generativo e riconoscitivo forniscono un ulteriore modo di descrivere i linguaggi.

% TODO: aggiungere un riferimento bibliografico che permetta al lettore di approfondire il concetto di sistema formale (e, volendo, calcolo logico)
\paragraph{Generatori} un generatore per un linguaggio $L\subseteq\Sigma\star$ è un sistema formale che produce parole appartenenti a $L$, cioè un metodo per costruirle a partire da regole.

\paragraph{Riconoscitori} un riconoscitore per un linguaggio $L\subseteq\Sigma\star$ è un algoritmo che determina se una data parola $w\in\Sigma\star$ appartiene a $L$.

Dato un riconoscitore o generatore $M$, si indica con $\generated M$ il linguaggio riconosciuto o generato da $M$.



\section{Grammatiche}
Le grammatiche, proposte in origine dal linguista Noam Chomsky negli anni '50, sono il principale generatore studiato nella teoria dei linguaggi formali. Esse consistono in un insieme di regole che costruiscono le parole del linguaggio generato trasformando in multipli modi e passi un assioma di partenza.
\begin{defin}[grammatica]
	Una grammatica (\eng{grammar}) è una quadrupla $G=\tuple{\Sigma,N,P,S}$, dove:
	\begin{itemize}
		\item $\Sigma$ è l'alfabeto dei simboli terminali (\eng{terminal symbols}), cioè dei simboli presenti nelle parole di $\generated G$;
		\item $N$ è l'alfabeto dei metasimboli (\eng{nonterminal symbols}), non presenti nelle parole di $\generated G$;
		\item $P$ è l'insieme delle regole di produzione (\eng{production rules}). Ogni regola è nella forma $(\Sigma\cup N)\star N(\Sigma\cup N)\star\to(\Sigma\cup N)$ e "trasforma" la parola (o fattore in una parola) a sinistra in quella a destra;
		\item $S\in N$ è l'assioma (\eng{start symbol}), cioè il punto di partenza delle derivazioni che danno origine alle parole di $\generated G$.
	\end{itemize}
	Data una grammatica $G=\tuple{\Sigma,N,P,S}$, si definisce la relazione binaria tra parole $\deriv{G}$, detta di derivazione in un passo:
	\begin{equation*}
		x\deriv{G} y \iff \exists u,v,p,q\in(\Sigma\cup N)\star \mid (x=upv)\land(p\to q\in P)\land(y=uqv)
	\end{equation*}
	e la relazione binaria tra parole $\derivs{G}$, detta di derivazione in zero o più passi (o semplicemente derivazione):
	\begin{itemize}
		\item $w \derivs{G} w \qquad\forall w\in\Sigma\star$
		\item $x \derivs{G} y \iff \exists w_1,w_2,\dots,w_m \mid x\deriv{G} w_1 \land w_1\deriv{G} w_2 \land\dots\land w_m\deriv{G}y$
	\end{itemize}
	Il linguaggio $\generated G$ generato da una grammatica $G=\tuple{\Sigma,N,P,S}$ è il linguaggio delle parole derivabili dall'assioma:
	\begin{equation*}
		\generated G := \set{w\in\Sigma\star\mid S\derivs{G} w}
	\end{equation*}
\end{defin}


\subsection{La Classificazione di Chomsky-Schützenberger}\label{subs:prel:chomshutz}
Nel 1956 Chomsky ha costruito in \cite{Chomsky:56:hier} una gerarchia di classi di grammatiche, basata sulla forma delle loro regole di produzione, da cui deriva una gerarchia di classi di linguaggi oggi considerata un concetto fondamentale della teoria dei linguaggi formali. La gerarchia si compone di quattro classi:
\begin{description}
	\item[Tipo 0] tutte le grammatiche sono di tipo 0;
	\item[Tipo 1] in una grammatica di tipo 1, ogni regola di produzione è nella forma $\alpha A\beta\to\alpha\gamma\beta$, dove $\gamma$ è non vuota e $A$ è un metasimbolo. È ammessa la regola $S\to\emptyword$, se $S$ è l'assioma, solo se $S$ non compare nella parte destra di alcuna altra regola. I linguaggi che possono essere generati da grammatiche di tipo 1 sono detti dipendenti dal contesto (\eng{context sensitive});
	\item[Tipo 2] in una grammatica di tipo 2, ogni regola di produzione $\alpha\to\beta$ è tale che $\alpha$ è un metasimbolo. Valgono le stesse restrizioni sull'assioma delle grammatiche di tipo 1. I linguaggi che possono essere generati da grammatiche di tipo 2 sono detti liberi dal contesto (\eng{context free});
	\item[Tipo 3] in una grammatica di tipo 3, ogni regola di produzione è in una delle forme $A\to\sigma B$, $A\to\sigma$, $A\to\emptyword$, dove $A$ e $B$ sono metasimboli e $\sigma$ è un simbolo terminale\footnote{L'esistenza della regola $A\to\sigma B$ dà luogo, per essere precisi, alla classe delle grammatiche regolari a destra (\eng{right regular}). Tale forma può essere sostituita (ma non accompagnata) da $A\to B\sigma$, dando luogo alle grammatiche regolari a sinistra (\eng{left regular}). Le due classi corrispondono alla stessa classe di linguaggi e sono considerate intercambiabili, anche se è più comune utilizzare le regolari a destra.}. I linguaggi che possono essere generati da grammatiche di tipo 3 sono detti regolari (\eng{regular}).
\end{description}
È facilmente verificabile che esiste un'inclusione tra le classi di grammatiche di tipo più alto e quelle di tipo più basso, da cui deriva un'inclusione, che si può dimostrare essere propria, tra le rispettive classi di linguaggi. Come vedremo, queste classi corrispondono inoltre a classi di riconoscitori.



\section{Riconoscitori}
% TODO: aggiungere immagini
% TODO: definire per ogni riconoscitore la funzione di transizione estesa, in modo da definire più formalmente l'accettazione? Da decidere
La tecnica dei riconoscitori corrisponde, nello studio moderno dei linguaggi, alla costruzione di macchine o automi. Essi sono modelli matematici che descrivono il comportamento di oggetti astratti in funzione di un input. In particolare una macchina, data una certa parola in input, può accettare o rifiutare la parola come appartenente al linguaggio riconosciuto. Formalmente, data una macchina $M$ che lavora su un alfabeto $\Sigma$:
\begin{equation*}
	\generated M := \set{w\in\Sigma\star\mid M\text{ accetta }w}
\end{equation*}
Per questo motivo di ogni modello si definisce il concetto di accettazione.

In questa sezione faremo riferimento alle definizioni formali contenute in \cite{Hopcroft:01:introLFA2}, in cui si può trovare anche la maggior parte delle dimostrazioni omesse. La macchina fondamentale, a cui tutte le altre sono riconducibili, è la macchina di Turing.


\subsection{Macchine di Turing}
La macchina di Turing, descritta per la prima volta da Alan Turing nel 1936, nasce come strumento per studiare la decidibilità di problemi. La macchina si compone di un nastro (\eng{tape}), una testina (\eng{head}) e un controllo finito (\eng{finite control}). Il nastro ha lunghezza infinita ed è diviso in celle, le prime celle contenenti l'input (un simbolo per cella), le seguenti il simbolo vuoto (\eng{blank symbol}). La testina punta a una cella del nastro (visita) ed è in grado di leggere e scrivere su di essa, scegliendo da un predeterminato alfabeto. Il controllo finito consiste in un insieme di stati di cui uno corrente. L'evoluzione della computazione di una macchina di Turing procede per istanti successivi, secondo una legge detta modello di transizione. Precisamente, la macchina, in funzione dello stato corrente e del simbolo letto dalla testina, sovrascrive il simbolo nella cella con un altro, cambia stato, e si muove in una direzione (sinistra o destra) in una cella adiacente. Questo procedimento è detto transizione o mossa. Lo stato corrente e i simboli sul nastro (più la posizione della testina) consistono nell'unica memoria della macchina.

\begin{defin}[macchina di Turing]
	Una macchina di Turing (\eng{Turing Machine}, abbreviata in TM) è una settupla $M=\tuple{Q,\Sigma,\Gamma,b,\delta,q_0,F}$, dove:
	\begin{itemize}
		\item $Q$ è un insieme finito e non vuoto di stati;
		\item $\Sigma$ è l'alfabeto di input, cioè dei simboli che si possono trovare sul nastro all'inizio della computazione (insieme a $b$);
		\item $\Gamma\supseteq\Sigma\cup\set{b}$ è un alfabeto di simboli per il nastro;
		\item $b\in\Gamma$ il simbolo vuoto, che ricorre infinitamente sul nastro al termine dell'input;
		\item $\delta:(Q\setminus F)\times\Gamma\nrightarrow Q\times\Gamma\times\set{L,R}$ è una funzione parziale detta di transizione. Se a un dato passo la macchina è nello stato $p$, la cella puntata dalla testina contiene $\sigma$, e $\delta(p,\sigma)=(q,\gamma,D)$, allora:
		      \begin{itemize}
			      \item $q$ è il prossimo stato;
			      \item $\gamma$ è il simbolo che verrà scritto in sostituzione a $x$ nella cella corrente, allo spostamento della testina;
			      \item $D$ e la direzione in cui si muoverà la testina, $L$ se a sinistra e $R$ se a destra\footnote{Talvolta si preferisce utilizzare $-1$ per sinistra e $+1$ per destra.}.
		      \end{itemize}
		\item $q_0\in Q$ è lo stato iniziale;
		\item $F\subseteq Q$ è l'insieme degli stati finali (o accettanti).
	\end{itemize}
	L'evoluzione della macchina consiste in una sequenza di \emph{configurazioni} (o descrizioni istantanee), ognuna composta da stato corrente, posizione della testina e simboli sul nastro. Una configurazione si indica con la notazione standard $xqy$, dove $x$ è la parola sul nastro prima della testina (può essere omessa se $x=\emptyword$), $q$ lo stato corrente e $y$ la parola sul nastro a partire dal simbolo puntato dalla testina, escludendo gli infiniti simboli vuoti presenti da una certa cella del nastro in poi (se la testina punta a un simbolo vuoto in coda, un certo numero di simboli vuoti sono contenuti in $x$ e $y=b$). Si scrive $xpy\trans{M} zqw$ (omettendo $G$ se sottinteso) se la configurazione $zqw$ si ottiene in una mossa da $xpy$, mentre $xpy\transs{M} zqw$ se si ottiene in zero o più mosse.

	Una macchina di Turing accetta una parola $w\in\Sigma\star$ se e solo se la sua computazione, a partire dalla configurazione $q_0w$, termina in uno stato finale.
\end{defin}
% La figura \ref{fig:prel:turmac} corrisponde alla tipica rappresentazione di una configurazione di una macchina di Turing.

\begin{examp}
	Se una TM è nella configurazione $xp\sigma y$, con $x,y\in\Gamma\star, p\in Q,\sigma\in\Gamma$, e $\delta(p,\sigma)=(q,\gamma,R)$, allora la prossima configurazione della macchina sarà $x\gamma qy$.
\end{examp}

Gli esiti possibili della computazione di una TM sono tre: la terminazione in uno stato finale (accettazione), la terminazione in uno stato non finale (rifiuto o \eng{crash}), la non terminazione (\eng{loop}), da interpretare come un rifiuto. È un noto risultato l'impossibilità di costruire un algoritmo che determini, data una qualunque coppia macchina di Turing - parola di input, se la macchina termini con il dato input.

Numerosi modelli alternativi, tutti equivalenti, sono stati presentati, variando ad esempio nel numero dei nastri, nel loro utilizzo (per esempio, un nastro di sola lettura per l'input e uno per la memoria scrivibile) e nell'infinità dell'estensione delle celle verso sinistra.

\subsubsection{Nondeterminismo}
È fondamentale citare il modello nondeterministico delle macchine di Turing e, in generale, delle macchine riconoscitrici. Una macchina di Turing nondeterministica (\eng{nondeterministic Turing machine}, abbreviata NTM) ha per modello di transizione una relazione del tipo $\delta:(Q\setminus F)\times\Gamma\nrightarrow \subsets{Q\times\Gamma\times\set{L,R}}$. Un modello di questo tipo descrive multiple possibilità per un passo dell'evoluzione della macchina, ciascuna descritta da uno degli elementi di un'immagine della funzione. Una parola in input è accettata se esiste una computazione, tra quelle coerenti con il modello, che termina in uno stato accettante.

In generale, una macchina riconoscitrice si dice nondeterministica quando il suo modello di transizione fornisce più possibilità per un passo evolutivo, e l'accettazione corrisponde all'esistenza di una computazione che termini accettando.

\subsubsection{Linguaggi ricorsivamente enumerabili e ricorsivi}
La classe dei linguaggi accettati da macchine di Turing è quella dei linguaggi ricorsivamente enumerabili.
\begin{defin}[linguaggio ricorsivamente enumerabile]
	Un linguaggio $L$ si dice ricorsivamente enumerabile (\eng{recursively enumerable}) se e solo se esiste una macchina di Turing $M$ che lo riconosce:
	\begin{equation*}
		w\in L \iff M \text{ termina in uno stato accettante}
	\end{equation*}
	Equivalentemente:
	\begin{equation*}
		w\notin L \iff M \text{ rifiuta o non termina}
	\end{equation*}
\end{defin}
Si può dimostrare che tale classe equivale a quella dei linguaggi generabili da grammatiche di tipo 0 della classificazione di Chomsky-Schützenberger (paragrafo \ref{subs:prel:chomshutz}). Poiché è possibile costruire una TM deterministica che riconosce lo stesso linguaggio di una data TM nondeterministica e viceversa, anche le NTM riconoscono la classe dei ricorsivamente enumerabili.

Esiste una classe la cui definizione è più restrittiva, poiché rimuove la possibilità di computazione non terminante: la classe dei linguaggi ricorsivi.
\begin{defin}[linguaggio ricorsivo]
	Un linguaggio $L$ si dice ricorsivo (\eng{recursive}) se e solo se esiste una macchina di Turing $M$ tale che per ogni parola in $L$, $M$ termina in uno stato accettante, mentre rifiuta esplicitamente ogni parola che non vi appartiene:
	\begin{equation*}
		\begin{cases}
			\text{$M$ termina in uno stato accettante} \qquad & \text{se } w\in L    \\
			\text{$M$ termina rifiutando} \qquad              & \text{se } w\notin L
		\end{cases}
	\end{equation*}
\end{defin}
Si può dimostrare che questa classe è propriamente inclusa nella classe dei ricorsivamente enumerabili, e non corrisponde ad alcuna classe della classificazione di Chomsky-Schützenberger.



\subsection{Automi a pila}
Gli automi a pila sono macchine composte da un controllo finito e una pila. Una pila (\eng{stack}) è una struttura dati che permettere di leggere e scrivere in maniera LIFO (\eng{last in, first out}). A ogni passo l'automa può leggere un simbolo dell'input, procedendo da sinistra verso destra, oppure leggere $\emptyword$. In funzione del simbolo letto e di quello sulla cima dello stack, l'automa cambia stato e scrive sulla cima dello stack una parola, sostituendo il simbolo letto.
\begin{defin}[automa a pila]
	Un automa a pila (\eng{pushdown automaton}, abbreviato in PDA) è una settupla $P=\tuple{Q,\Sigma,\Gamma,\delta,q_0,Z_0,F}$, dove:
	\begin{itemize}
		\item $Q$ è un insieme finito e non vuoto di stati;
		\item $\Sigma$ è l'alfabeto di input;
		\item $\Gamma$ è un alfabeto di simboli per la pila;
		\item $\delta:Q\times(\Sigma\cup\set{\emptyword})\times\Gamma\to \fsubsets{Q\times\Gamma\star}$ è la funzione di transizione. Se a un dato passo l'automa è nello stato $p$, legge il simbolo $\sigma$ (potenzialmente vuoto), sulla cima della pila c'è il simbolo $X$ e $\delta(p,\sigma,X)\ni (p,w)$, allora l'automa può passare allo stato $q$, scrivere sulla cima dello stack la parola $w$ in sostituzione a $X$ (\verb!pop! di $X$ e \verb!push! di $w$) e passare alla lettura del simbolo successivo (cioè quello immediatamente a destra di quello corrente). La macchina ha, in generale, più possibilità per un passo evolutivo, operando in maniera nondeterministica;
		\item $q_0\in Q$ è lo stato iniziale;
		\item $Z_0$ è l'unico simbolo contenuto nella pila all'inizio della computazione;
		\item $F\subseteq Q$ è l'insieme degli stati finali.
	\end{itemize}
	Un PDA accetta una parola $w\in\Sigma\star$ se e solo se esiste una computazione che, a partire dallo stato $q_0$, con la pila contenente $Z_0$ e dalla lettura del primo simbolo di $w$, termina con uno dei seguenti risultati:
	\begin{itemize}
		\item lo stato corrente è finale;
		\item la pila è vuota.
	\end{itemize}
\end{defin}

Un PDA può essere simulato da una macchina di Turing nondeterministica a due nastri, di cui uno contiene l'input e l'altro simula la pila.
Come le macchine di Turing, gli automi a pila hanno una controparte deterministica. Tuttavia, contrariamente alle TM, essa non equivale, nel potere riconoscitivo, alla versione nondeterministica.
\begin{defin}[automa a pila deterministico]
	Un automa a pila deterministico (\eng{deterministic pushdown automaton}, abbreviato in DPDA) è un PDA in cui:
	\begin{itemize}
		\item $\card{\delta(q,a,X)}\leq 1\quad \forall q\in Q, a\in\Sigma\cup\set{\emptyword}, X\in\Gamma$;
		\item $\card{\delta(q,a,X)}>0\impl \delta(q,\emptyword,X)=\emptyset$.
	\end{itemize}
\end{defin}

Si può dimostrare che la classe di linguaggi riconosciuta da PDA coincide con la classe dei linguaggi liberi da contesto (in riferimento alla classificazione di Chomsky-Schützenberger al paragrafo \ref{subs:prel:chomshutz}). I DPDA riconoscono una sottoclasse propria dei linguaggi liberi da contesto, chiamata semplicemente linguaggi liberi da contesto deterministici e la cui non trova posto nella classificazione. Una migliore classificazione per i linguaggi liberi da contesto deterministici è stata introdotta da Hibbard in \cite{Hibbard:67:CFdet} tramite gli automi \eng{$d$-limited}.


\subsection{Automi a stati finiti}

\subsubsection{NFA e DFA}
\begin{defin}[automa a stati finiti nondeterministico]
	Un automa a stati finiti nondeterministico (\eng{nondeterministic finite automaton}, abbreviato in NFA) è una quintupla $A=\tuple{Q,\Sigma,\delta,q_0,F}$, dove:
	\begin{itemize}
		\item $Q$ è un insieme finito e non vuoto di stati;
		\item $\Sigma$ è l'alfabeto di input;
		\item $\delta:Q\times\Sigma\to\subsets{Q}$ è la funzione di transizione. Se a un dato passo l'automa è nello stato $p$, legge il simbolo $\sigma$, e $\delta(p,\sigma)\ni q$, allora l'automa può passare allo stato $q$ e alla lettura del simbolo successivo. La macchina ha, in generale, più possibilità per un passo evolutivo, operando in maniera nondeterministica;
		\item $q_0\in Q$ è lo stato iniziale;
		\item $F\subseteq Q$ è l'insieme degli stati finali.
	\end{itemize}
	Un NFA accetta una parola $w\in\Sigma\star$ se e solo se esiste una computazione che, a partire dallo stato $q_0$ e dalla lettura del primo simbolo a sinistra, termina in uno stato finale.
\end{defin}
\begin{defin}
	Un automa a stati finiti deterministico (\eng{deterministic finite automaton}, abbreviato in DFA) è un NFA in cui $\card{\delta(q,\sigma)}\leq 1 ~ \forall q\in Q,\sigma\in\Sigma$.
\end{defin}

Un NFA $A=\tuple{Q,\Sigma,\delta,q_0,F}$ può essere facilmente simulato da una macchina di Turing nondeterministica $M=\tuple{Q,\Sigma,\Sigma\cup\set{b},b,\delta',q_0,F}$, costruendo per ogni regola $\delta(p,\sigma)\ni q$ di $A$ una regola $\delta'(p,\sigma)\ni (q,\sigma,R)$. Si può inoltre dimostrare che si può costruire una grammatica di tipo 3 che generi il linguaggio riconosciuto da un dato NFA e viceversa, ossia che la classe riconosciuta dagli NFA è quella dei linguaggi regolari.

La tabella \ref{tab:prel:chomskyhier} riassume la classificazione di Chomsky-Schützenberger completa di corrispondenza con le rispettive classi di linguaggi e riconoscitori.

\begin{table}
	\caption{Classificazione di Chomsky-Schützenberger con corrispondenza con le rispettive classi di linguaggi e riconoscitori. $a$ è un simbolo terminale, $A$ e $B$ metasimboli, $\alpha$, $\beta$ e $\gamma$ parole qualunque, con $\gamma$ non vuota. Una macchina di Turing linearmente limitata è una macchina di Turing la cui lunghezza del nastro è funzione lineare della dimensione dell'input.}
	\label{tab:prel:chomskyhier}
	\centering
	\begin{tabularx}{\textwidth}{lXXl}
		\toprule
		\textbf{Grammatica} & \textbf{Linguaggi generabili} & \textbf{Riconoscitore}                  & \textbf{Regole di produzione}         \\
		\midrule
		Tipo 0              & Ricorsivamente enumerabili    & Macchine di Turing                      & $\gamma\to\alpha$                     \\
		Tipo 1              & Dipendenti dal contesto       & Macchine di Turing linearmente limitate & $\alpha A\beta\to\alpha\gamma\beta$   \\
		Tipo 2              & Liberi dal contesto           & Automi a pila                           & $A\to\alpha$                          \\
		Tipo 3              & Regolari                      & Automi a stati finiti                   & $A\to a$, $A\to aB$, $A\to\emptyword$ \\
		\bottomrule
	\end{tabularx}
\end{table}

\subsubsection{Automi \eng{two-way}}
Un altro sistema equivalente a quello degli NFA per riconoscere i linguaggi regolari è quello degli automi \eng{two-way}, simili ad essi ma con la capacità di muoversi in ambe le direzioni tra i simboli dell'input. Useremo la formalizzazione di \cite{Pighizzini:14:limitedRE}, poiché si avvicina molto a quella per gli automi \eng{limited}. L'equivalenza degli automi two-way deterministici e DFA è discussa in \cite{Shallit:09:secondLFA}.

Un automa a stati finiti two-way ha le stesse componenti di una macchina di Turing: controllo finito, nastro e testina. Tuttavia, esso non può effettuare operazioni di scrittura; inoltre, può visitare unicamente le celle che in origine contengono l'input. Questo è infatti delimitato da due simboli speciali, il \eng{left} ($\lem$) e il \eng{right} ($\rem$) \eng{end-marker}, oltre i quali la testina non può muoversi.
\begin{defin}
	Un automa a stati finiti \eng{2-way} nondeterministico (\eng{2-way finite automaton}, abbreviato in 2NFA) è una quintupla $A=\tuple{Q,\Sigma,\delta,q_0,F}$, dove:
	\begin{itemize}
		\item $Q$ è un insieme finito e non vuoto di stati;
		\item $\Sigma$ è l'alfabeto di input;
		\item $\delta:Q\times(\Sigma\cup\set{\lem,\rem})\to\subsets{Q\times\set{L,R}}$ è la funzione di transizione. Se a un dato passo l'automa è nello stato $p$, legge il simbolo $\sigma$, e $\delta(p,\sigma)\ni (q,D)$, allora l'automa può passare allo stato $q$ e alla lettura del simbolo alla sinistra di quello corrente se $D=L$, o alla sua destra se $D=R$. Non è possibile muoversi a sinistra di $\lem$ e a destra di $\rem$, se non per accettare. La macchina ha, in generale, più possibilità per un passo evolutivo, operando in maniera nondeterministica;
		\item $q_0\in Q$ è lo stato iniziale;
		\item $F\subseteq Q$ è l'insieme degli stati finali.
	\end{itemize}
	I simboli speciali $\lem$ e $\rem$ circoscrivono l'input nonché lo spazio di lavoro sul nastro.

	Un 2NFA accetta una parola $w\in\Sigma\star$ se e solo se esiste una computazione che, a partire dallo stato $q_0$ e dalla lettura del primo simbolo dell'input (il nastro contenente $\lem w\rem$), termina in uno stato finale $q\in F$ violando il \eng{right end-marker}.
\end{defin}
Talvolta, per distinguerli dalle loro controparti two-way, gli NFA \eng{one-way} si abbreviano con 1NFA e, analogamente, i DFA con 1DFA.

Come anticipato, i 2NFA hanno un equivalente deterministico:
\begin{defin}
	Un automa a stati finiti \eng{two-way} deterministico (\eng{2-way deterministic finite automaton}, abbreviato in 2DFA) è un 2NFA in cui $\card{\delta(q,\sigma)}\leq 1 ~ \forall q\in Q,\sigma\in\Sigma\cup\set{\lem,\rem}$.
\end{defin}



\section{Complessità descrizionale}
